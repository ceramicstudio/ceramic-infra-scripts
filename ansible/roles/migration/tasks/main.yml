---
# Stop services
- name: Stop js-ceramic-3 node
  ansible.builtin.systemd:
    name: js-ceramic
    state: stopped
  when: inventory_hostname == 'gitcoin-js-ceramic-3.3boxlabs.com'

- name: Stop go-ipfs Docker container
  ansible.builtin.shell:
    cmd: docker-compose down
    chdir: /opt/go-ipfs
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'
  register: docker_compose_result

# PostgreSQL migration
- name: Stream and apply PostgreSQL schema from hirenodes_pg to GCP SQL DB
  ansible.builtin.shell:
    cmd: |
      set -e
      # Dump the schema
      ssh -i ~/.ssh/id_hirenodes root@{{ hirenodes_pg_host }} \
      "su - postgres -c \"PGPASSWORD='{{ hirenodes_pg_password }}' pg_dump -v -h localhost -U {{ hirenodes_pg_user }} -d {{ hirenodes_pg_database }} --no-owner --no-acl --schema-only\"" > /tmp/schema.sql

      # Apply the schema, ignoring errors
      PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -f /tmp/schema.sql || true

      # Clean up
      rm /tmp/schema.sql
  delegate_to: gitcoin-js-ceramic-3.3boxlabs.com
  environment:
    PGSSLMODE: require
  when: inventory_hostname == 'gitcoin-js-ceramic-3.3boxlabs.com'
  become: no
#  no_log: true

- name: Get list of tables from source database
  ansible.builtin.shell:
    cmd: |
      ssh -i ~/.ssh/id_hirenodes root@{{ hirenodes_pg_host }} \
      "su - postgres -c \"psql -d {{ hirenodes_pg_database }} -t -c \\\"SELECT trim(tablename) FROM pg_tables WHERE schemaname = 'public' AND tablename != 'schema_migrations' ORDER BY tablename;\\\"\""
  register: table_list
  when: inventory_hostname == 'gitcoin-js-ceramic-3.3boxlabs.com'
  become: no

- name: Incremental PostgreSQL data transfer table by table
  ansible.builtin.shell:
    cmd: |
      set -o pipefail
      
      table_name="{{ item | trim }}"
      
      if [ "$table_name" = "ceramic_model_implements" ]; then
        # Full copy for ceramic_model_implements table
        PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -c "TRUNCATE TABLE $table_name"
        ssh -i ~/.ssh/id_hirenodes root@{{ hirenodes_pg_host }} \
        "su - postgres -c \"PGPASSWORD='{{ hirenodes_pg_password }}' psql -h localhost -U {{ hirenodes_pg_user }} -d {{ hirenodes_pg_database }} -c \\\"COPY $table_name TO STDOUT\\\" | gzip -c\"" | \
        gunzip | \
        PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -v ON_ERROR_STOP=1 -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -c "COPY $table_name FROM STDIN"
        
        rows_transferred=$(PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -t -c "SELECT COUNT(*) FROM $table_name")
        echo "Transferred $rows_transferred rows for table $table_name (full copy)"
      else
        # Incremental update for other tables
        latest_timestamp=$(PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -t -c "SELECT COALESCE(MAX(created_at), NULL) FROM $table_name" | xargs)
        if [ -z "$latest_timestamp" ]; then
          # If no entries have been copied, get the earliest created_at from the source table
          latest_timestamp=$(ssh -i ~/.ssh/id_hirenodes root@{{ hirenodes_pg_host }} \
          "su - postgres -c \"PGPASSWORD='{{ hirenodes_pg_password }}' psql -h localhost -U {{ hirenodes_pg_user }} -d {{ hirenodes_pg_database }} -t -c \\\"SELECT MIN(created_at) FROM $table_name\\\"\"" | xargs)
        fi
        
        echo "Latest timestamp for $table_name: $latest_timestamp"
        
        # Get the maximum timestamp from the source table
        max_timestamp=$(ssh -i ~/.ssh/id_hirenodes root@{{ hirenodes_pg_host }} \
        "su - postgres -c \"PGPASSWORD='{{ hirenodes_pg_password }}' psql -h localhost -U {{ hirenodes_pg_user }} -d {{ hirenodes_pg_database }} -t -c \\\"SELECT MAX(created_at) FROM $table_name\\\"\"" | xargs)
        
        current_timestamp=$latest_timestamp
        total_rows_transferred=0
        
        while [[ "$current_timestamp" < "$max_timestamp" ]]; do
          next_timestamp=$(date -d "$current_timestamp + 1 day" +"%Y-%m-%d %H:%M:%S")
          
          ssh -i ~/.ssh/id_hirenodes root@{{ hirenodes_pg_host }} \
          "su - postgres -c \"PGPASSWORD='{{ hirenodes_pg_password }}' psql -h localhost -U {{ hirenodes_pg_user }} -d {{ hirenodes_pg_database }} -c \\\"COPY (SELECT * FROM $table_name WHERE created_at > '$current_timestamp' AND created_at <= '$next_timestamp') TO STDOUT\\\" | gzip -c\"" | \
          gunzip | \
          PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -v ON_ERROR_STOP=1 -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -c "COPY $table_name FROM STDIN"
          
          rows_transferred=$(PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -t -c "SELECT COUNT(*) FROM $table_name WHERE created_at > '$current_timestamp' AND created_at <= '$next_timestamp'")
          total_rows_transferred=$((total_rows_transferred + rows_transferred))
          echo "Transferred $rows_transferred rows for table $table_name (incremental, $current_timestamp to $next_timestamp)"
          
          current_timestamp=$next_timestamp
        done
        
        echo "Total transferred $total_rows_transferred rows for table $table_name (incremental)"
      fi
  args:
    executable: /bin/bash
  delegate_to: gitcoin-js-ceramic-3.3boxlabs.com
  environment:
    PGSSLMODE: require
  register: pg_data_migration_result
  failed_when: pg_data_migration_result.rc != 0
  loop: "{{ table_list.stdout_lines }}"
  when: inventory_hostname == 'gitcoin-js-ceramic-3.3boxlabs.com'
  become: no

- name: Display summary of transferred rows
  ansible.builtin.debug:
    msg: "{{ pg_data_migration_result.results | map(attribute='stdout_lines') | flatten | select('match', '^(Transferred|Total transferred|Latest timestamp)') | list }}"
  when: inventory_hostname == 'gitcoin-js-ceramic-3.3boxlabs.com'

# Ceramic migration
- name: Stream Ceramic statestore from hirenodes_ceramic to gitcoin-js-ceramic-3
  ansible.builtin.synchronize:
    src: "{{ ceramic_statestore_path }}/"
    dest: "{{ data_store_mount_path }}/"
    mode: pull
    delete: yes
    rsync_opts:
      - "--compress"
      - "--archive"
  delegate_to: gitcoin-js-ceramic-3.3boxlabs.com
  vars:
    ansible_ssh_private_key: "{{ hirenodes_ceramic_ssh_key }}"

# IPFS migration
- name: Get current timestamp
  ansible.builtin.set_fact:
    timestamp: "{{ ansible_date_time.iso8601_basic_short }}"
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'

- name: Backup IPFS config file with timestamp
  ansible.builtin.copy:
    src: "{{ data_store_mount_path }}/ipfs-data/config"
    dest: "~/ipfs_config_backup_{{ timestamp }}"
    remote_src: yes
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'

- name: Stream ZFS snapshot from hirenodes_ipfs to gitcoin-go-ipfs-1
  ansible.builtin.shell:
    cmd: zfs send -i ipfs/ipfs@initial {{ remote_latest_snapshot.stdout }}
  delegate_to: hirenodes_ipfs
  register: zfs_send_output
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'

- name: Apply ZFS snapshot on gitcoin-go-ipfs-1
  ansible.builtin.shell:
    cmd: zfs receive -F ipfspool/data-store
  args:
    stdin: "{{ zfs_send_output.stdout }}"
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'
  register: zfs_receive_result
  failed_when: zfs_receive_result.rc != 0

- name: Restore IPFS config file
  ansible.builtin.copy:
    src: "/home/{{ ansible_user }}/ipfs_config_backup_{{ timestamp }}"
    dest: "{{ data_store_mount_path }}/ipfs-data/config"
    remote_src: yes
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'

- name: Create symlink to latest config backup
  ansible.builtin.file:
    src: "/home/{{ ansible_user }}/ipfs_config_backup_{{ timestamp }}"
    dest: "/home/{{ ansible_user }}/ipfs_config_backup_latest"
    state: link
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'

# Start services
- name: Start go-ipfs-1 node
  ansible.builtin.systemd:
    name: go-ipfs
    state: started
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'

- name: Start js-ceramic-3 node
  ansible.builtin.systemd:
    name: js-ceramic
    state: started
  when: inventory_hostname == 'gitcoin-js-ceramic-3.3boxlabs.com'
