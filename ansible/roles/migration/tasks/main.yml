---
# Stop services
- name: Stop js-ceramic-3 node
  ansible.builtin.systemd:
    name: js-ceramic
    state: stopped
  when: inventory_hostname == 'gitcoin-js-ceramic-3.3boxlabs.com'

- name: Stop go-ipfs Docker container
  ansible.builtin.shell:
    cmd: docker-compose down
    chdir: /opt/go-ipfs
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'
  register: docker_compose_result

# PostgreSQL migration
- name: Stream and apply PostgreSQL schema from hirenodes_pg to GCP SQL DB
  ansible.builtin.shell:
    cmd: |
      set -e
      # Dump the schema
      ssh -i ~/.ssh/id_hirenodes root@{{ hirenodes_pg_host }} \
      "su - postgres -c \"PGPASSWORD='{{ hirenodes_pg_password }}' pg_dump -v -h localhost -U {{ hirenodes_pg_user }} -d {{ hirenodes_pg_database }} --no-owner --no-acl --schema-only\"" > /tmp/schema.sql

      # Apply the schema, ignoring errors
      PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -f /tmp/schema.sql || true

      # Clean up
      rm /tmp/schema.sql
  delegate_to: gitcoin-js-ceramic-3.3boxlabs.com
  environment:
    PGSSLMODE: require
  when: inventory_hostname == 'gitcoin-js-ceramic-3.3boxlabs.com'
  become: no
#  no_log: true

- name: Get list of tables from source database
  ansible.builtin.shell:
    cmd: |
      ssh -i ~/.ssh/id_hirenodes root@{{ hirenodes_pg_host }} \
      "su - postgres -c \"psql -d {{ hirenodes_pg_database }} -t -c \\\"SELECT trim(tablename) FROM pg_tables WHERE schemaname = 'public' AND tablename != 'schema_migrations' ORDER BY tablename;\\\"\""
  register: table_list
  when: inventory_hostname == 'gitcoin-js-ceramic-3.3boxlabs.com'
  become: no

- name: Incremental PostgreSQL data transfer table by table
  ansible.builtin.shell:
    cmd: |
      set -o pipefail
      
      # Set up reverse SSH tunnel from gitcoin to hirenodes
      ssh -f -N -R 5433:{{ ceramic_indexing_db_host }}:5432 -i ~/.ssh/id_hirenodes root@{{ hirenodes_pg_host }}
      if [ $? -ne 0 ]; then
        echo "Failed to establish SSH tunnel"
        exit 1
      fi

      # Ensure tunnel is closed on exit
      trap 'ssh -i ~/.ssh/id_hirenodes root@{{ hirenodes_pg_host }} "pkill -f \"ssh -f -N -R 5433:{{ ceramic_indexing_db_host }}:5432\""' EXIT
      
      table_name="{{ item | trim }}"
      
      if [[ "$table_name" =~ ^(ceramic_model_implements|ceramic_config|ceramic_models)$ ]]; then
        # Full copy for specified tables
        PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -c "TRUNCATE TABLE $table_name"
        ssh -i ~/.ssh/id_hirenodes root@{{ hirenodes_pg_host }} \
        "su - postgres -c \"PGPASSWORD='{{ hirenodes_pg_password }}' psql -h localhost -U {{ hirenodes_pg_user }} -d {{ hirenodes_pg_database }} -c \\\"COPY $table_name TO STDOUT\\\" | gzip -c\"" | \
        gunzip | \
        PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -v ON_ERROR_STOP=1 -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -c "COPY $table_name FROM STDIN"
        
        rows_transferred=$(PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -t -c "SELECT COUNT(*) FROM $table_name")
        echo "Transferred $rows_transferred rows for table $table_name (full copy)"
      else
        # Get the latest timestamp from the destination table
        latest_timestamp=$(PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -t -c "SELECT COALESCE(TO_CHAR(GREATEST(MAX(created_at), MAX(updated_at)), 'YYYY-MM-DD HH24:MI:SS.US'), '1970-01-01 00:00:00.000000') FROM $table_name" | xargs)
        
        echo "Latest timestamp for $table_name: $latest_timestamp"
        
        # Generate the column list for SET clause, preserving case
        columns=$(PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -t -c "SELECT string_agg('\"' || column_name || '\"', ', ') FROM information_schema.columns WHERE table_name = '$table_name' AND column_name != 'stream_id'")
        
        # Generate a truncated temporary table name
        temp_table_name="temp_${table_name:0:58}"  # 63 characters max, leaving room for "temp_"

        # Find missing and updated rows
        ssh -i ~/.ssh/id_hirenodes root@{{ hirenodes_pg_host }} \
        "su - postgres -c \"PGPASSWORD='{{ hirenodes_pg_password }}' psql -h localhost -U {{ hirenodes_pg_user }} -d {{ hirenodes_pg_database }} -c \\\"
          COPY (
            SELECT s.* FROM $table_name s
             LEFT JOIN dblink('host=localhost port=5433 user={{ ceramic_indexing_db_user }} password={{ ceramic_indexing_db_password }} dbname={{ ceramic_indexing_db_name }}',
                             'SELECT stream_id, updated_at FROM $table_name') AS d(stream_id text, updated_at timestamp)
            ON s.stream_id = d.stream_id
            WHERE d.stream_id IS NULL OR s.updated_at > d.updated_at OR s.updated_at > '$latest_timestamp'::timestamp
          ) TO STDOUT
        \\\" | gzip -c\"" | \
        gunzip | \
        PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -v ON_ERROR_STOP=1 -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -c "
          CREATE TEMP TABLE $temp_table_name (LIKE $table_name INCLUDING ALL);
          COPY $temp_table_name FROM STDIN;
          INSERT INTO $table_name
          SELECT * FROM $temp_table_name
          ON CONFLICT (stream_id) DO UPDATE
          SET ($columns) = (SELECT $columns FROM $temp_table_name WHERE $temp_table_name.stream_id = $table_name.stream_id);
          DROP TABLE $temp_table_name;
        "

        rows_transferred=$(PGPASSWORD='{{ ceramic_indexing_db_password }}' psql -h {{ ceramic_indexing_db_host }} -U {{ ceramic_indexing_db_user }} -d {{ ceramic_indexing_db_name }} -t -c "SELECT COUNT(*) FROM $table_name WHERE created_at > '$latest_timestamp'::timestamp OR updated_at > '$latest_timestamp'::timestamp")
        echo "Transferred $rows_transferred rows for table $table_name (incremental)"
      fi
  args:
    executable: /bin/bash
  delegate_to: gitcoin-js-ceramic-3.3boxlabs.com
  environment:
    PGSSLMODE: require
  register: pg_data_migration_result
  failed_when: pg_data_migration_result.rc != 0
  loop: "{{ table_list.stdout_lines }}"
  when: inventory_hostname == 'gitcoin-js-ceramic-3.3boxlabs.com'
  become: no

- name: Display summary of transferred rows
  ansible.builtin.debug:
    msg: "{{ pg_data_migration_result.results | map(attribute='stdout_lines') | flatten | select('match', '^(Transferred|Latest timestamp)') | list }}"
  when: inventory_hostname == 'gitcoin-js-ceramic-3.3boxlabs.com'

# Ceramic migration
- name: Stream Ceramic statestore from hirenodes_ceramic to gitcoin-js-ceramic-3
  ansible.builtin.synchronize:
    src: "{{ ceramic_statestore_path }}/"
    dest: "{{ data_store_mount_path }}/"
    mode: pull
    delete: yes
    rsync_opts:
      - "--compress"
      - "--archive"
  delegate_to: gitcoin-js-ceramic-3.3boxlabs.com
  vars:
    ansible_ssh_private_key: "{{ hirenodes_ceramic_ssh_key }}"

# IPFS migration
- name: Get current timestamp
  ansible.builtin.set_fact:
    timestamp: "{{ ansible_date_time.iso8601_basic_short }}"
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'

- name: Backup IPFS config file with timestamp
  ansible.builtin.copy:
    src: "{{ data_store_mount_path }}/ipfs-data/config"
    dest: "~/ipfs_config_backup_{{ timestamp }}"
    remote_src: yes
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'

- name: Stream ZFS snapshot from hirenodes_ipfs to gitcoin-go-ipfs-1
  ansible.builtin.shell:
    cmd: zfs send -i ipfs/ipfs@initial {{ remote_latest_snapshot.stdout }}
  delegate_to: hirenodes_ipfs
  register: zfs_send_output
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'

- name: Apply ZFS snapshot on gitcoin-go-ipfs-1
  ansible.builtin.shell:
    cmd: zfs receive -F ipfspool/data-store
  args:
    stdin: "{{ zfs_send_output.stdout }}"
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'
  register: zfs_receive_result
  failed_when: zfs_receive_result.rc != 0

- name: Restore IPFS config file
  ansible.builtin.copy:
    src: "/home/{{ ansible_user }}/ipfs_config_backup_{{ timestamp }}"
    dest: "{{ data_store_mount_path }}/ipfs-data/config"
    remote_src: yes
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'

- name: Create symlink to latest config backup
  ansible.builtin.file:
    src: "/home/{{ ansible_user }}/ipfs_config_backup_{{ timestamp }}"
    dest: "/home/{{ ansible_user }}/ipfs_config_backup_latest"
    state: link
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'

# Start services
- name: Start go-ipfs-1 node
  ansible.builtin.systemd:
    name: go-ipfs
    state: started
  when: inventory_hostname == 'gitcoin-go-ipfs-1.3boxlabs.com'

- name: Start js-ceramic-3 node
  ansible.builtin.systemd:
    name: js-ceramic
    state: started
  when: inventory_hostname == 'gitcoin-js-ceramic-3.3boxlabs.com'
